from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
import shutil
import subprocess
import tempfile
from typing import Any

from src.schema_project_io import load_project_from_json
from src.schema_project_model import ForeignKeySpec, SchemaProject, TableSpec


def _erd_error(field: str, issue: str, hint: str) -> str:
    return f"ERD Designer / {field}: {issue}. Fix: {hint}."


@dataclass(frozen=True)
class ERDNode:
    table_name: str
    lines: list[str]
    x: int
    y: int
    width: int
    height: int


@dataclass(frozen=True)
class ERDEdge:
    parent_table: str
    parent_column: str
    child_table: str
    child_column: str


def load_project_schema_for_erd(path_value: Any) -> SchemaProject:
    if not isinstance(path_value, str) or path_value.strip() == "":
        raise ValueError(
            _erd_error(
                "Schema path",
                "path is required",
                "choose an existing schema project JSON file",
            )
        )

    path = Path(path_value.strip())
    if not path.exists():
        raise ValueError(
            _erd_error(
                "Schema path",
                f"path '{path}' does not exist",
                "choose an existing schema project JSON file",
            )
        )

    try:
        return load_project_from_json(str(path))
    except Exception as exc:
        raise ValueError(
            _erd_error(
                "Schema input",
                f"failed to load schema JSON from '{path}' ({exc})",
                "provide a valid schema project JSON file generated by this application",
            )
        ) from exc


def _fk_columns_by_table(project: SchemaProject) -> dict[str, set[str]]:
    out: dict[str, set[str]] = {}
    for fk in project.foreign_keys:
        out.setdefault(fk.child_table, set()).add(fk.child_column)
    return out


def build_table_detail_lines(
    table: TableSpec,
    *,
    fk_columns: set[str],
    show_columns: bool,
    show_dtypes: bool,
) -> list[str]:
    if not show_columns:
        return []

    lines: list[str] = []
    for col in table.columns:
        tags: list[str] = []
        if col.primary_key:
            tags.append("PK")
        if col.name in fk_columns:
            tags.append("FK")
        tag_text = f"[{','.join(tags)}] " if tags else ""
        dtype_text = f": {col.dtype}" if show_dtypes else ""
        lines.append(f"{tag_text}{col.name}{dtype_text}")
    return lines


def _table_levels(project: SchemaProject) -> dict[str, int]:
    table_names = sorted(t.table_name for t in project.tables)
    parents_by_child: dict[str, set[str]] = {name: set() for name in table_names}
    for fk in project.foreign_keys:
        parents_by_child.setdefault(fk.child_table, set()).add(fk.parent_table)

    levels: dict[str, int] = {}
    for name in table_names:
        if not parents_by_child.get(name):
            levels[name] = 0

    progress = True
    while progress:
        progress = False
        for name in table_names:
            if name in levels:
                continue
            parents = parents_by_child.get(name, set())
            if parents and all(parent in levels for parent in parents):
                levels[name] = max(levels[parent] for parent in parents) + 1
                progress = True

    # Cycles should be rare/invalid; keep deterministic fallback layout.
    for name in table_names:
        levels.setdefault(name, 0)
    return levels


def build_erd_layout(
    project: SchemaProject,
    *,
    show_columns: bool,
    show_dtypes: bool,
    node_width: int = 300,
    header_height: int = 30,
    line_height: int = 18,
    margin: int = 32,
    column_gap: int = 110,
    row_gap: int = 24,
) -> tuple[list[ERDNode], list[ERDEdge], int, int]:
    table_map = {t.table_name: t for t in project.tables}
    levels = _table_levels(project)
    fk_columns_by_table = _fk_columns_by_table(project)

    names_by_level: dict[int, list[str]] = {}
    for table_name, level in levels.items():
        names_by_level.setdefault(level, []).append(table_name)
    for names in names_by_level.values():
        names.sort()

    nodes: list[ERDNode] = []
    max_y = margin
    max_level = max(levels.values(), default=0)

    for level in sorted(names_by_level.keys()):
        x = margin + level * (node_width + column_gap)
        y = margin
        for table_name in names_by_level[level]:
            table = table_map[table_name]
            lines = build_table_detail_lines(
                table,
                fk_columns=fk_columns_by_table.get(table_name, set()),
                show_columns=show_columns,
                show_dtypes=show_dtypes,
            )
            line_count = max(1, len(lines))
            height = header_height + 12 + (line_count * line_height)
            node = ERDNode(
                table_name=table_name,
                lines=lines,
                x=x,
                y=y,
                width=node_width,
                height=height,
            )
            nodes.append(node)
            y += height + row_gap
        max_y = max(max_y, y)

    edges = [
        ERDEdge(
            parent_table=fk.parent_table,
            parent_column=fk.parent_column,
            child_table=fk.child_table,
            child_column=fk.child_column,
        )
        for fk in sorted(
            project.foreign_keys,
            key=lambda fk: (fk.parent_table, fk.child_table, fk.parent_column, fk.child_column),
        )
    ]

    width = margin * 2 + (max_level + 1) * node_width + max_level * column_gap
    height = max(max_y + margin, margin * 2 + 200)
    return nodes, edges, width, height


def edge_label(edge: ERDEdge) -> str:
    return f"{edge.child_table}.{edge.child_column} -> {edge.parent_table}.{edge.parent_column}"


def node_anchor_y(node: ERDNode, *, table: TableSpec, column_name: str) -> int:
    # Keep relationship anchor near the related column when columns are visible.
    header_base = node.y + 30 + 6
    for idx, col in enumerate(table.columns):
        if col.name == column_name:
            return int(header_base + idx * 18)
    return int(node.y + node.height / 2)


def table_for_edge(
    edge: ERDEdge,
    *,
    table_map: dict[str, TableSpec],
) -> tuple[TableSpec, TableSpec]:
    try:
        parent = table_map[edge.parent_table]
        child = table_map[edge.child_table]
    except KeyError as exc:
        raise ValueError(
            _erd_error(
                "Relationships",
                f"edge references unknown table '{exc.args[0]}'",
                "ensure FK tables exist in schema input",
            )
        ) from exc
    return parent, child


def relation_lines(project: SchemaProject) -> list[ForeignKeySpec]:
    return sorted(
        project.foreign_keys,
        key=lambda fk: (fk.parent_table, fk.child_table, fk.parent_column, fk.child_column),
    )


def apply_node_position_overrides(
    nodes: list[ERDNode],
    *,
    positions: dict[str, tuple[int, int]] | None,
) -> list[ERDNode]:
    if not positions:
        return list(nodes)

    out: list[ERDNode] = []
    for node in nodes:
        moved = positions.get(node.table_name)
        if moved is None:
            out.append(node)
            continue
        out.append(
            ERDNode(
                table_name=node.table_name,
                lines=node.lines,
                x=int(moved[0]),
                y=int(moved[1]),
                width=node.width,
                height=node.height,
            )
        )
    return out


def compute_diagram_size(
    nodes: list[ERDNode],
    *,
    min_width: int,
    min_height: int,
    margin: int = 32,
) -> tuple[int, int]:
    max_right = max((node.x + node.width for node in nodes), default=0)
    max_bottom = max((node.y + node.height for node in nodes), default=0)
    return max(min_width, max_right + margin), max(min_height, max_bottom + margin)


def _xml_escape(value: str) -> str:
    return (
        value.replace("&", "&amp;")
        .replace("<", "&lt;")
        .replace(">", "&gt;")
        .replace('"', "&quot;")
        .replace("'", "&apos;")
    )


def build_erd_svg(
    project: SchemaProject,
    *,
    show_relationships: bool,
    show_columns: bool,
    show_dtypes: bool,
    node_positions: dict[str, tuple[int, int]] | None = None,
) -> str:
    nodes, edges, base_width, base_height = build_erd_layout(
        project,
        show_columns=show_columns,
        show_dtypes=show_dtypes,
    )
    nodes = apply_node_position_overrides(nodes, positions=node_positions)
    width, height = compute_diagram_size(nodes, min_width=base_width, min_height=base_height)
    node_by_table = {node.table_name: node for node in nodes}
    table_map = {table.table_name: table for table in project.tables}

    lines: list[str] = []
    lines.append('<?xml version="1.0" encoding="UTF-8"?>')
    lines.append(
        f'<svg xmlns="http://www.w3.org/2000/svg" width="{width}" height="{height}" viewBox="0 0 {width} {height}">'
    )
    lines.append(f'  <rect x="0" y="0" width="{width}" height="{height}" fill="#f3f6fb" />')

    for node in nodes:
        x1 = node.x
        y1 = node.y
        x2 = node.x + node.width
        header_h = 30
        lines.append(
            f'  <rect x="{x1}" y="{y1}" width="{node.width}" height="{node.height}" fill="#ffffff" stroke="#556b8a" stroke-width="2" />'
        )
        lines.append(
            f'  <rect x="{x1}" y="{y1}" width="{node.width}" height="{header_h}" fill="#dae7f8" stroke="#556b8a" stroke-width="2" />'
        )
        lines.append(
            f'  <text x="{x1 + 8}" y="{y1 + 20}" font-family="Segoe UI, Arial, sans-serif" font-size="13" font-weight="bold" fill="#1a2a44">{_xml_escape(node.table_name)}</text>'
        )

        detail_lines = node.lines if node.lines else ["(columns hidden)"]
        y = y1 + 48
        for line in detail_lines:
            lines.append(
                f'  <text x="{x1 + 8}" y="{y}" font-family="Consolas, Courier New, monospace" font-size="11" fill="#27374d">{_xml_escape(line)}</text>'
            )
            y += 18
        _ = x2  # keep shape parity/readability

    if show_relationships:
        for edge in edges:
            parent_node = node_by_table.get(edge.parent_table)
            child_node = node_by_table.get(edge.child_table)
            if parent_node is None or child_node is None:
                continue
            try:
                parent_table, child_table = table_for_edge(edge, table_map=table_map)
            except ValueError:
                continue

            if show_columns:
                y1 = node_anchor_y(parent_node, table=parent_table, column_name=edge.parent_column)
                y2 = node_anchor_y(child_node, table=child_table, column_name=edge.child_column)
            else:
                y1 = int(parent_node.y + parent_node.height / 2)
                y2 = int(child_node.y + child_node.height / 2)

            x1 = parent_node.x + parent_node.width
            x2 = child_node.x
            mid_x = int((x1 + x2) / 2)
            path = f"M {x1} {y1} L {mid_x} {y1} L {mid_x} {y2} L {x2} {y2}"
            lines.append(
                f'  <path d="{path}" fill="none" stroke="#1f5a95" stroke-width="2" marker-end="url(#arrow)" />'
            )
            label = _xml_escape(edge_label(edge))
            lines.append(
                f'  <text x="{mid_x + 6}" y="{int((y1 + y2) / 2) - 7}" font-family="Segoe UI, Arial, sans-serif" font-size="10" fill="#1f5a95">{label}</text>'
            )

    lines.insert(
        3,
        '  <defs><marker id="arrow" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto"><polygon points="0 0, 10 3.5, 0 7" fill="#1f5a95" /></marker></defs>',
    )
    lines.append("</svg>")
    return "\n".join(lines) + "\n"


def _find_ghostscript_executable() -> str | None:
    candidates = [
        "gswin64c",
        "gswin32c",
        "gs",
    ]
    for name in candidates:
        resolved = shutil.which(name)
        if resolved:
            return resolved

    # Common Windows install roots as fallback.
    common_roots = [
        Path("C:/Program Files/gs"),
        Path("C:/Program Files (x86)/gs"),
    ]
    for root in common_roots:
        if not root.exists():
            continue
        for version_dir in sorted(root.glob("*"), reverse=True):
            candidate = version_dir / "bin" / "gswin64c.exe"
            if candidate.exists():
                return str(candidate)
            candidate = version_dir / "bin" / "gswin32c.exe"
            if candidate.exists():
                return str(candidate)
    return None


def _export_raster_with_ghostscript(
    *,
    output_path: Path,
    postscript_data: str,
    raster_format: str,
) -> None:
    gs = _find_ghostscript_executable()
    if gs is None:
        raise ValueError(
            _erd_error(
                "Export",
                f"{raster_format.upper()} export requires Ghostscript but it was not found",
                "install Ghostscript (gswin64c) or export as SVG",
            )
        )

    device = "pngalpha" if raster_format == "png" else "jpeg"
    with tempfile.NamedTemporaryFile(suffix=".ps", delete=False) as tmp:
        ps_path = Path(tmp.name)
        tmp.write(postscript_data.encode("utf-8"))

    cmd = [
        gs,
        "-dSAFER",
        "-dBATCH",
        "-dNOPAUSE",
        f"-sDEVICE={device}",
        "-r160",
        f"-sOutputFile={output_path}",
        str(ps_path),
    ]
    try:
        proc = subprocess.run(cmd, capture_output=True, text=True, check=False)
    finally:
        try:
            ps_path.unlink()
        except OSError:
            pass

    if proc.returncode != 0:
        stderr = (proc.stderr or "").strip()
        details = stderr.splitlines()[0] if stderr else f"ghostscript exit code {proc.returncode}"
        raise ValueError(
            _erd_error(
                "Export",
                f"failed to export {raster_format.upper()} ({details})",
                "verify Ghostscript is installed and retry, or export as SVG",
            )
        )


def export_erd_file(
    *,
    output_path_value: Any,
    svg_text: str,
    postscript_data: str | None = None,
) -> Path:
    if not isinstance(output_path_value, str) or output_path_value.strip() == "":
        raise ValueError(
            _erd_error(
                "Export path",
                "output path is required",
                "choose a file path ending in .svg, .png, .jpg, or .jpeg",
            )
        )
    output_path = Path(output_path_value.strip())
    ext = output_path.suffix.lower()
    if ext not in {".svg", ".png", ".jpg", ".jpeg"}:
        raise ValueError(
            _erd_error(
                "Export format",
                f"unsupported extension '{ext or '<none>'}'",
                "use .svg, .png, .jpg, or .jpeg",
            )
        )

    output_path.parent.mkdir(parents=True, exist_ok=True)

    if ext == ".svg":
        output_path.write_text(svg_text, encoding="utf-8")
        return output_path

    if postscript_data is None or postscript_data.strip() == "":
        raise ValueError(
            _erd_error(
                "Export source",
                f"{ext[1:].upper()} export requires rendered canvas postscript data",
                "render the ERD before exporting",
            )
        )
    _export_raster_with_ghostscript(
        output_path=output_path,
        postscript_data=postscript_data,
        raster_format="png" if ext == ".png" else "jpeg",
    )
    return output_path
